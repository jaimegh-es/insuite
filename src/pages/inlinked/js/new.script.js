// Mapeos de caracteres Unicode para Mathematical Sans
const mathSansNormal = {
    'A': 'ð– ', 'B': 'ð–¡', 'C': 'ð–¢', 'D': 'ð–£', 'E': 'ð–¤', 'F': 'ð–¥', 'G': 'ð–¦', 'H': 'ð–§', 'I': 'ð–¨', 'J': 'ð–©',
    'K': 'ð–ª', 'L': 'ð–«', 'M': 'ð–¬', 'N': 'ð–­', 'O': 'ð–®', 'P': 'ð–¯', 'Q': 'ð–°', 'R': 'ð–±', 'S': 'ð–²', 'T': 'ð–³',
    'U': 'ð–´', 'V': 'ð–µ', 'W': 'ð–¶', 'X': 'ð–·', 'Y': 'ð–¸', 'Z': 'ð–¹',
    'a': 'ð–º', 'b': 'ð–»', 'c': 'ð–¼', 'd': 'ð–½', 'e': 'ð–¾', 'f': 'ð–¿', 'g': 'ð—€', 'h': 'ð—', 'i': 'ð—‚', 'j': 'ð—ƒ',
    'k': 'ð—„', 'l': 'ð—…', 'm': 'ð—†', 'n': 'ð—‡', 'o': 'ð—ˆ', 'p': 'ð—‰', 'q': 'ð—Š', 'r': 'ð—‹', 's': 'ð—Œ', 't': 'ð—',
    'u': 'ð—Ž', 'v': 'ð—', 'w': 'ð—', 'x': 'ð—‘', 'y': 'ð—’', 'z': 'ð—“',
    '0': 'ðŸ¢', '1': 'ðŸ£', '2': 'ðŸ¤', '3': 'ðŸ¥', '4': 'ðŸ¦', '5': 'ðŸ§', '6': 'ðŸ¨', '7': 'ðŸ©', '8': 'ðŸª', '9': 'ðŸ«'
};

const mathSansBold = {
    'A': 'ð—”', 'B': 'ð—•', 'C': 'ð—–', 'D': 'ð——', 'E': 'ð—˜', 'F': 'ð—™', 'G': 'ð—š', 'H': 'ð—›', 'I': 'ð—œ', 'J': 'ð—',
    'K': 'ð—ž', 'L': 'ð—Ÿ', 'M': 'ð— ', 'N': 'ð—¡', 'O': 'ð—¢', 'P': 'ð—£', 'Q': 'ð—¤', 'R': 'ð—¥', 'S': 'ð—¦', 'T': 'ð—§',
    'U': 'ð—¨', 'V': 'ð—©', 'W': 'ð—ª', 'X': 'ð—«', 'Y': 'ð—¬', 'Z': 'ð—­',
    'a': 'ð—®', 'b': 'ð—¯', 'c': 'ð—°', 'd': 'ð—±', 'e': 'ð—²', 'f': 'ð—³', 'g': 'ð—´', 'h': 'ð—µ', 'i': 'ð—¶', 'j': 'ð—·',
    'k': 'ð—¸', 'l': 'ð—¹', 'm': 'ð—º', 'n': 'ð—»', 'o': 'ð—¼', 'p': 'ð—½', 'q': 'ð—¾', 'r': 'ð—¿', 's': 'ð˜€', 't': 'ð˜',
    'u': 'ð˜‚', 'v': 'ð˜ƒ', 'w': 'ð˜„', 'x': 'ð˜…', 'y': 'ð˜†', 'z': 'ð˜‡',
    '0': 'ðŸ¬', '1': 'ðŸ­', '2': 'ðŸ®', '3': 'ðŸ¯', '4': 'ðŸ°', '5': 'ðŸ±', '6': 'ðŸ²', '7': 'ðŸ³', '8': 'ðŸ´', '9': 'ðŸµ'
};

const mathSansItalic = {
    'A': 'ð˜ˆ', 'B': 'ð˜‰', 'C': 'ð˜Š', 'D': 'ð˜‹', 'E': 'ð˜Œ', 'F': 'ð˜', 'G': 'ð˜Ž', 'H': 'ð˜', 'I': 'ð˜', 'J': 'ð˜‘',
    'K': 'ð˜’', 'L': 'ð˜“', 'M': 'ð˜”', 'N': 'ð˜•', 'O': 'ð˜–', 'P': 'ð˜—', 'Q': 'ð˜˜', 'R': 'ð˜™', 'S': 'ð˜š', 'T': 'ð˜›',
    'U': 'ð˜œ', 'V': 'ð˜', 'W': 'ð˜ž', 'X': 'ð˜Ÿ', 'Y': 'ð˜ ', 'Z': 'ð˜¡',
    'a': 'ð˜¢', 'b': 'ð˜£', 'c': 'ð˜¤', 'd': 'ð˜¥', 'e': 'ð˜¦', 'f': 'ð˜§', 'g': 'ð˜¨', 'h': 'ð˜©', 'i': 'ð˜ª', 'j': 'ð˜«',
    'k': 'ð˜¬', 'l': 'ð˜­', 'm': 'ð˜®', 'n': 'ð˜¯', 'o': 'ð˜°', 'p': 'ð˜±', 'q': 'ð˜²', 'r': 'ð˜³', 's': 'ð˜´', 't': 'ð˜µ',
    'u': 'ð˜¶', 'v': 'ð˜·', 'w': 'ð˜¸', 'x': 'ð˜¹', 'y': 'ð˜º', 'z': 'ð˜»'
};

const mathSansBoldItalic = {
    'A': 'ð˜¼', 'B': 'ð˜½', 'C': 'ð˜¾', 'D': 'ð˜¿', 'E': 'ð™€', 'F': 'ð™', 'G': 'ð™‚', 'H': 'ð™ƒ', 'I': 'ð™„', 'J': 'ð™…',
    'K': 'ð™†', 'L': 'ð™‡', 'M': 'ð™ˆ', 'N': 'ð™‰', 'O': 'ð™Š', 'P': 'ð™‹', 'Q': 'ð™Œ', 'R': 'ð™', 'S': 'ð™Ž', 'T': 'ð™',
    'U': 'ð™', 'V': 'ð™‘', 'W': 'ð™’', 'X': 'ð™“', 'Y': 'ð™”', 'Z': 'ð™•',
    'a': 'ð™–', 'b': 'ð™—', 'c': 'ð™˜', 'd': 'ð™™', 'e': 'ð™š', 'f': 'ð™›', 'g': 'ð™œ', 'h': 'ð™', 'i': 'ð™ž', 'j': 'ð™Ÿ',
    'k': 'ð™ ', 'l': 'ð™¡', 'm': 'ð™¢', 'n': 'ð™£', 'o': 'ð™¤', 'p': 'ð™¥', 'q': 'ð™¦', 'r': 'ð™§', 's': 'ð™¨', 't': 'ð™©',
    'u': 'ð™ª', 'v': 'ð™«', 'w': 'ð™¬', 'x': 'ð™­', 'y': 'ð™®', 'z': 'ð™¯'
};

// Estado de la aplicaciÃ³n
let currentFormat = 'normal';

// Elementos del DOM
const textEditor = document.getElementById('textEditor');
const copyBtn = document.getElementById('copyBtn');
const formatButtons = document.querySelectorAll('.new-format-btn');

// Mapeos inversos para convertir de nuevo a normal
const mathSansBoldReverse = Object.fromEntries(Object.entries(mathSansBold).map(([key, value]) => [value, key]));
const mathSansItalicReverse = Object.fromEntries(Object.entries(mathSansItalic).map(([key, value]) => [value, key]));
const mathSansBoldItalicReverse = Object.fromEntries(Object.entries(mathSansBoldItalic).map(([key, value]) => [value, key]));

// FunciÃ³n para convertir texto segÃºn el formato seleccionado, handling existing formats
function convertText(text, format) {
    // First, convert any existing formatted characters back to normal
    let normalText = '';
    for (const char of text) {
        if (mathSansBoldReverse[char]) {
            normalText += mathSansBoldReverse[char];
        } else if (mathSansItalicReverse[char]) {
            normalText += mathSansItalicReverse[char];
        } else if (mathSansBoldItalicReverse[char]) {
            normalText += mathSansBoldItalicReverse[char];
        } else {
            normalText += char;
        }
    }
    
    // If the target format is 'normal', return the normalized text directly
    if (format === 'normal') {
        return normalText;
    }

    // Otherwise, apply the new format mapping to the normalized text
    let mapping;
    switch (format) {
        case 'bold':
            mapping = mathSansBold;
            break;
        case 'italic':
            mapping = mathSansItalic;
            break;
        case 'bolditalic':
            mapping = mathSansBoldItalic;
            break;
        default:
             // This case should ideally not be reached if format buttons are correctly set
             mapping = mathSansNormal;
    }
    
    return normalText.split('').map(char => mapping[char] || char).join('');
}

// FunciÃ³n para aplicar formato al texto seleccionado
function applyFormatToSelection() {
    const selection = window.getSelection();
    
    if (selection.rangeCount === 0) return;
    
    const range = selection.getRangeAt(0);
    const selectedText = range.toString();
    
    if (selectedText.length === 0) return;
    
    // The convertText function now handles converting from any format to the target format
    const processedText = convertText(selectedText, currentFormat);
    
    // Reemplazar el texto seleccionado con el texto procesado
    range.deleteContents();
    range.insertNode(document.createTextNode(processedText));
    
    // Limpiar la selecciÃ³n
    selection.removeAllRanges();
}

// Manejo de botones de formato
formatButtons.forEach(button => {
    button.addEventListener('click', () => {
        // Remover clase active de todos los botones
        formatButtons.forEach(btn => btn.classList.remove('active'));
        
        // Agregar clase active al botÃ³n clickeado
        button.classList.add('active');
        
        // Actualizar formato actual
        currentFormat = button.dataset.format;
        
        // Aplicar formato si hay texto seleccionado
        applyFormatToSelection();
        
        // Mantener el foco en el editor
        textEditor.focus();
    });
});


// FunciÃ³n para copiar al portapapeles
async function copyToClipboard() {
    const textToCopy = textEditor.textContent;
    
    if (!textToCopy.trim()) {
        return;
    }
    
    try {
        await navigator.clipboard.writeText(textToCopy);
        
        // Feedback visual
        const originalText = copyBtn.textContent;
        copyBtn.textContent = 'âœ… Â¡Copiado!';
        copyBtn.classList.add('copied');
        
        setTimeout(() => {
            copyBtn.textContent = originalText;
            copyBtn.classList.remove('copied');
        }, 2000);
        
    } catch (err) {
        // Fallback para navegadores mÃ¡s antiguos
        const textArea = document.createElement('textarea');
        textArea.value = textToCopy;
        document.body.appendChild(textArea);
        textArea.select();
        
        try {
            document.execCommand('copy');
            copyBtn.textContent = 'âœ… Â¡Copiado!';
            copyBtn.classList.add('copied');
            
            setTimeout(() => {
                copyBtn.textContent = 'ðŸ“‹ Copiar';
                copyBtn.classList.remove('copied');
            }, 2000);
        } catch (fallbackErr) {
            console.error('Error al copiar:', fallbackErr);
            alert('No se pudo copiar el texto. Por favor, selecciona y copia manualmente.');
        }
        
        document.body.removeChild(textArea);
    }
}

// InicializaciÃ³n
document.addEventListener('DOMContentLoaded', () => {
    textEditor.focus();
    console.log('LinkedIn Sans Stylizer cargado correctamente');
    // AÃ±adir el event listener aquÃ­, solo si copyBtn existe
    if (copyBtn) {
        copyBtn.addEventListener('click', copyToClipboard);
    }
    
    // Manejar teclas de acceso rÃ¡pido
    textEditor.addEventListener('keydown', (e) => {
        if (e.ctrlKey || e.metaKey) {
            switch (e.key) {
                case 'b':
                    e.preventDefault();
                    document.querySelector('[data-format="bold"]').click();
                    break;
                case 'i':
                    e.preventDefault();
                    document.querySelector('[data-format="italic"]').click();
                    break;
            }
        }
    });
});